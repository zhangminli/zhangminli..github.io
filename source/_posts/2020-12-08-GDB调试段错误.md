---
title: GDB调试段错误
date: 2020-12-08 20:03:24
tags: c++
---

#### GDB

GDB 全称“GNU symbolic debugger”，从名称上不难看出，它诞生于 GNU 计划（同时诞生的还有 GCC、Emacs 等），是 Linux 下常用的程序调试器。发展至今，GDB 已经迭代了诸多个版本，当下的 GDB 支持调试多种编程语言编写的程序，包括 C、C++、Go、Objective-C、OpenCL、Ada 等。实际场景中，GDB 更常用来调试 C 和 C++ 程序。

<!--more-->

总的来说，借助 GDB 调试器可以实现以下几个功能：

1. 程序启动时，可以按照我们自定义的要求运行程序，例如设置参数和环境变量；
2. 可使被调试程序在指定代码处暂停运行，并查看当前程序的运行状态（例如当前变量的值，函数的执行结果等），即支持断点调试；
3. 程序执行过程中，可以改变某个变量的值，还可以改变代码的执行顺序，从而尝试修改程序中出现的逻辑错误。

判断当前 Linux 发行版是否安装有 GDB 的方法也很简单，就是在命令行窗口中执行 gdb -v 命令。如果显示以下信息，则说明该系统以及安装了GDB。

```shell
[root@bogon ~]# gdb -v
GNU gdb (GDB) Red Hat Enterprise Linux (7.2-92.el6)
Copyright (C) 2010 Free Software Foundation, Inc.
.......
```

参考链接：http://c.biancheng.net/view/8123.html

#### 段错误

一旦一个程序发生了越界访问，CPU就会产生相应的保护，于是segmentation fault就出现了。通俗来讲，段错误应该就是访问了不可访问的内存，这个内存区要么是不存在的，要么是受到系统保护的，还有可能是缺少文件或者文件损坏。

在编程中以下几类做法容易导致段错误,基本上是错误地使用[指针](https://baike.baidu.com/item/指针)引起的。

1. 访问系统数据区，尤其是往系统保护的内存地址写数据最常见就是给一个指针以0地址。

2. 内存越界(数组越界，变量类型不一致等)： 访问到不属于你的内存区域。

   

#### 示例

在我们的案例中，程序通过make编译了一个可执行文件tests。

运行：

```shell
# gdb ./test
```

得到如下显示：

```
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
---Type <return> to continue, or q <return> to quit---
```

输入crtl，继续输入

```
(gdb) r
```

程序会继续执行，直到发生段错误，无需打断点，并显示类似如下错误信息

```shell
Thread 1 "tests" received signal SIGSEGV, Segmentation fault.
0x00007ffff6216cf1 in __GI___libc_free (mem=0x5555557bd066 <aca_oam_server::ACA_Oam_Server::_parse_oam_none(unsigned int, aca_oam_server::oam_message*)>) at malloc.c:3133
3133    malloc.c: No such file or directory.
```

从以上信息可以看到，发生段错误的位置大概在aca_oam_server::ACA_Oam_Server::_parse_oam_none这个方法。

我们继续输入

```shell
(gdb) backtrace

#0  0x00007ffff6216cf1 in __GI___libc_free (mem=0x5555557bd066 <aca_oam_server::ACA_Oam_Server::_parse_oam_none(unsigned int, aca_oam_server::oam_message*)>) at malloc.c:3133
#1  0x00005555557a419a in __gnu_cxx::new_allocator<std::__detail::_Hash_node_base*>::deallocate (this=0x7fffffffe2df, 
    __p=0x5555557bd066 <aca_oam_server::ACA_Oam_Server::_parse_oam_none(unsigned int, aca_oam_server::oam_message*)>) at /usr/include/c++/7/ext/new_allocator.h:125
#2  0x00005555557a1bcc in std::allocator_traits<std::allocator<std::__detail::_Hash_node_base*> >::deallocate (__a=..., 
    __p=0x5555557bd066 <aca_oam_server::ACA_Oam_Server::_parse_oam_none(unsigned int, aca_oam_server::oam_message*)>, __n=0) at /usr/include/c++/7/bits/alloc_traits.h:462
#3  0x00005555557bea0b in std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<unsigned int, false> > >::_M_deallocate_buckets (
    this=0x555555ba9c50 <aca_oam_server::ACA_Oam_Server::get_instance()::instance+48>, __bkts=0x5555557bd066 <aca_oam_server::ACA_Oam_Server::_parse_oam_none(unsigned int, aca_oam_server::oam_message*)>, __n=0)
    at /usr/include/c++/7/bits/hashtable_policy.h:2121
#4  0x00005555557be636 in std::_Hashtable<unsigned int, unsigned int, std::allocator<unsigned int>, std::__detail::_Identity, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true> >::_M_deallocate_buckets (
```

通过运行 (gdb) frame 序号可以查看更具体的信息

如：

```
(gdb) frame 0
#0  0x00007ffff6216cf1 in __GI___libc_free (mem=0x5555557bd066 <aca_oam_server::ACA_Oam_Server::_parse_oam_none(unsigned int, aca_oam_server::oam_message*)>) at malloc.c:3133
3133    in malloc.c
```

我们检查代码，发现声明了一个函数数组

```c++
void (aca_oam_server::ACA_Oam_Server ::*_parse_oam_msg_ops[3])(uint32_t udp_dpost,oam_message *oammsg);
```

但在赋值时发生了

```c++
_parse_oam_msg_ops[3] = &aca_oam_server::ACA_Oam_Server::_parse_oam_none;
```

数组下标越界，导致发生了段错误。

